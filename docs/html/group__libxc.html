<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Embedded Xinu Operating System: C library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Embedded Xinu Operating System
   </div>
   <div id="projectbrief">An ongoing research project and educational operating system.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">C library</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple C library supporting a number of standard functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaeb20b44c8437544e571a3cb9bb2cc37d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gaeb20b44c8437544e571a3cb9bb2cc37d">abs</a> (int j)</td></tr>
<tr class="separator:gaeb20b44c8437544e571a3cb9bb2cc37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad228deceea1bac4d9f171f647c265059"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gad228deceea1bac4d9f171f647c265059">atoi</a> (const char *nptr)</td></tr>
<tr class="separator:gad228deceea1bac4d9f171f647c265059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185551efd32d058ef290ebe2d144219f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga185551efd32d058ef290ebe2d144219f">atol</a> (const char *nptr)</td></tr>
<tr class="separator:ga185551efd32d058ef290ebe2d144219f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59505af7f1c47ff01fdb944801642033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga59505af7f1c47ff01fdb944801642033">bzero</a> (void *s, size_t n)</td></tr>
<tr class="separator:ga59505af7f1c47ff01fdb944801642033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48b30d4bbe6f24fac50996ad08dee81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gaf48b30d4bbe6f24fac50996ad08dee81">_doprnt</a> (const char *fmt, va_list ap, int(*putc_func)(int, int), int putc_arg)</td></tr>
<tr class="separator:gaf48b30d4bbe6f24fac50996ad08dee81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166404d618b580eb27442b03d55004fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga166404d618b580eb27442b03d55004fd">_doscan</a> (const char *fmt, va_list ap, int(*getch)(int, int), int(*ungetch)(int, int), int arg1, int arg2)</td></tr>
<tr class="separator:ga166404d618b580eb27442b03d55004fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331dd7c56def5258f0385d1e5f9220c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga331dd7c56def5258f0385d1e5f9220c1">fgetc</a> (int dev)</td></tr>
<tr class="separator:ga331dd7c56def5258f0385d1e5f9220c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573c8ad59f73c997adb58ea83a5a879a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga573c8ad59f73c997adb58ea83a5a879a">fgets</a> (char *s, int n, int dev)</td></tr>
<tr class="separator:ga573c8ad59f73c997adb58ea83a5a879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4112ec293c0482854c66caaa708457c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga4112ec293c0482854c66caaa708457c2">fprintf</a> (int dev, const char *format,...)</td></tr>
<tr class="separator:ga4112ec293c0482854c66caaa708457c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f19bdc96eb7c1eda177e01344f8c74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga32f19bdc96eb7c1eda177e01344f8c74">fputc</a> (int c, int dev)</td></tr>
<tr class="separator:ga32f19bdc96eb7c1eda177e01344f8c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52df17ca21d792b6abb1559a77feaa13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga52df17ca21d792b6abb1559a77feaa13">fputs</a> (const char *s, int dev)</td></tr>
<tr class="separator:ga52df17ca21d792b6abb1559a77feaa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbedc913aa4651b3c3b4b3aecd9b4711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gafbedc913aa4651b3c3b4b3aecd9b4711">free</a> (void *ptr)</td></tr>
<tr class="separator:gafbedc913aa4651b3c3b4b3aecd9b4711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9412bab60c15683f2cbf5397970bf38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gaf9412bab60c15683f2cbf5397970bf38">fscanf</a> (int dev, const char *format,...)</td></tr>
<tr class="separator:gaf9412bab60c15683f2cbf5397970bf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912277f2dbf3594e958d116ff2b35625"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga912277f2dbf3594e958d116ff2b35625">labs</a> (long j)</td></tr>
<tr class="separator:ga912277f2dbf3594e958d116ff2b35625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac38fce3243a7dcf448301ee9ffd392"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga7ac38fce3243a7dcf448301ee9ffd392">malloc</a> (size_t size)</td></tr>
<tr class="separator:ga7ac38fce3243a7dcf448301ee9ffd392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16d6b0bd660cc3f9910924c6b6f4af8e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga16d6b0bd660cc3f9910924c6b6f4af8e">memchr</a> (const void *s, int c, size_t n)</td></tr>
<tr class="separator:ga16d6b0bd660cc3f9910924c6b6f4af8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e6df54ee04e18a3772335580e2ed872"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga9e6df54ee04e18a3772335580e2ed872">memcmp</a> (const void *s1, const void *s2, size_t n)</td></tr>
<tr class="separator:ga9e6df54ee04e18a3772335580e2ed872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14938524dcbeb59d7117ba5e151ad1b1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga14938524dcbeb59d7117ba5e151ad1b1">memcpy</a> (void *dest, const void *src, size_t n)</td></tr>
<tr class="separator:ga14938524dcbeb59d7117ba5e151ad1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace6ee45c30e71865e6eb635200379db9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gace6ee45c30e71865e6eb635200379db9">memset</a> (void *s, int c, size_t n)</td></tr>
<tr class="separator:gace6ee45c30e71865e6eb635200379db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98631211a4a8aee62f572375d5b637be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga98631211a4a8aee62f572375d5b637be">printf</a> (const char *format,...)</td></tr>
<tr class="separator:ga98631211a4a8aee62f572375d5b637be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216aaec88b41d3e2f8502a5b3365ea81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga216aaec88b41d3e2f8502a5b3365ea81">qsort</a> (void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *))</td></tr>
<tr class="separator:ga216aaec88b41d3e2f8502a5b3365ea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76dd6cc9eff8b0475a781caf9782d73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gaa76dd6cc9eff8b0475a781caf9782d73">srand</a> (unsigned int x)</td></tr>
<tr class="separator:gaa76dd6cc9eff8b0475a781caf9782d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23144bcbb8e3742b00eb687c36654d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gae23144bcbb8e3742b00eb687c36654d1">rand</a> (void)</td></tr>
<tr class="separator:gae23144bcbb8e3742b00eb687c36654d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3082155ec11e7229f7a20439b31a169e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga3082155ec11e7229f7a20439b31a169e">sprintf</a> (char *str, const char *format,...)</td></tr>
<tr class="separator:ga3082155ec11e7229f7a20439b31a169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1e54556dca3bd701d44395d34818dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gaec1e54556dca3bd701d44395d34818dd">sscanf</a> (const char *str, const char *format,...)</td></tr>
<tr class="separator:gaec1e54556dca3bd701d44395d34818dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12871ed234858ef0e363d2b8aa572fc1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga12871ed234858ef0e363d2b8aa572fc1">strchr</a> (const char *s, int c)</td></tr>
<tr class="separator:ga12871ed234858ef0e363d2b8aa572fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bd144d7d44914099a3aeddf1c8567d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga11bd144d7d44914099a3aeddf1c8567d">strcmp</a> (const char *s1, const char *s2)</td></tr>
<tr class="separator:ga11bd144d7d44914099a3aeddf1c8567d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a82515b5d377be04817715c5465b647"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga7a82515b5d377be04817715c5465b647">strcpy</a> (char *dest, const char *src)</td></tr>
<tr class="separator:ga7a82515b5d377be04817715c5465b647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0c58f8ba41f9267161ffca2ea92558"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga3e0c58f8ba41f9267161ffca2ea92558">strlcpy</a> (char *dest, const char *src, size_t destsize)</td></tr>
<tr class="separator:ga3e0c58f8ba41f9267161ffca2ea92558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa383452fe445bfae989358c9d7d96f4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gaa383452fe445bfae989358c9d7d96f4f">strlen</a> (const char *s)</td></tr>
<tr class="separator:gaa383452fe445bfae989358c9d7d96f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aee928c2844a269966e4832fd2255c5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga0aee928c2844a269966e4832fd2255c5">strncat</a> (char *dest, const char *src, size_t n)</td></tr>
<tr class="separator:ga0aee928c2844a269966e4832fd2255c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f4a84c11c106e95c32b6ab509346ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga07f4a84c11c106e95c32b6ab509346ef">strncmp</a> (const char *s1, const char *s2, size_t n)</td></tr>
<tr class="separator:ga07f4a84c11c106e95c32b6ab509346ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d54f24198df56da51078a6c540b9ed"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga47d54f24198df56da51078a6c540b9ed">strncpy</a> (char *dest, const char *src, size_t n)</td></tr>
<tr class="separator:ga47d54f24198df56da51078a6c540b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc92d2231e45d19988c7894aa2a07f0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#gafc92d2231e45d19988c7894aa2a07f0c">strnlen</a> (const char *s, size_t maxlen)</td></tr>
<tr class="separator:gafc92d2231e45d19988c7894aa2a07f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c05a458deff028ef4d4e64059098db4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga0c05a458deff028ef4d4e64059098db4">strrchr</a> (const char *s, int c)</td></tr>
<tr class="separator:ga0c05a458deff028ef4d4e64059098db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a710d86541afc6b7dafddcdb4b1c94f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__libxc.html#ga4a710d86541afc6b7dafddcdb4b1c94f">strstr</a> (const char *haystack, const char *needle)</td></tr>
<tr class="separator:ga4a710d86541afc6b7dafddcdb4b1c94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A simple C library supporting a number of standard functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf48b30d4bbe6f24fac50996ad08dee81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _doprnt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int, int)&#160;</td>
          <td class="paramname"><em>putc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>putc_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write formatted output.</p>
<p>This is a simplified implementation, and not all standard conversion specifications are supported. A conversion specification (a sequence beginning with the <code>''</code> character) is divided into 5 parts, the first four of which are optional. The following list explains the features supported by this implementation, broken down by part of the conversion specification:</p>
<ol type="1">
<li>Flags: 0+ of the following:<ul>
<li><code>"-"</code> to specify left-justification</li>
<li><code>"0"</code> to specify zero padding</li>
</ul>
</li>
<li>Minimum field width: 0-1 of the following:<ul>
<li>A series of decimal digits not beginning with 0 that specifies the minimum field width as a non-negative integer</li>
<li><code>"*"</code>, indicating that the minimum field width is given as an <code>int</code> variadic argument</li>
</ul>
</li>
<li>Precision: 0-1 of the following:<ul>
<li><code>".PREC"</code>, where <code>PREC</code> is a series of decimal digits that specifies the precision as a non-negative integer</li>
<li><code>"*"</code>, indicating that the precision is given as an <code>int</code> variadic argument</li>
</ul>
</li>
<li>Length modifier for signed and unsigned integer conversions: 0-1 of the following:<ul>
<li><code>"hh"</code> for <code>signed char</code> or <code>unsigned char</code></li>
<li><code>"h"</code> for <code>signed short</code> or <code>unsigned short</code></li>
<li><code>"l"</code> for <code>signed long</code> or <code>unsigned long</code></li>
</ul>
</li>
<li>Conversion specifier character: 1 of the following:<ul>
<li><code>"\%d"</code> to format a signed integer in decimal (base 10)</li>
<li><code>"\%b"</code> to format an unsigned integer in binary (base 2)</li>
<li><code>"\%o"</code> to format an unsigned integer in octal (base 8)</li>
<li><code>"\%u"</code> to format an unsigned integer in decimal (base 10)</li>
<li><code>"\%x"</code> to format an unsigned integer in lower case hex (base 16)</li>
<li><code>"\%X"</code> to format an unsigned integer in upper case hex (base 16)</li>
<li><code>"\%c"</code> to format a single character</li>
<li><code>"\%s"</code> to format a null-terminated string, or "(null)" for a <code>NULL</code> pointer</li>
<li><code>"\%\%"</code> to format a literal percent sign</li>
</ul>
</li>
</ol>
<p>If a feature is not mentioned above, assume it is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>Format string. </td></tr>
    <tr><td class="paramname">ap</td><td>Variable-length list of values that will be formatted. </td></tr>
    <tr><td class="paramname">putc_func</td><td>Character output function. It is passed two arguments; the first will be the character to output, and the second will be <code>putc_arg</code>. It is expected to return <code>EOF</code> on failure. </td></tr>
    <tr><td class="paramname">putc_arg</td><td>Second argument to <code>putc_func</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters written on success, or <code>EOF</code> on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga166404d618b580eb27442b03d55004fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _doscan </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int, int)&#160;</td>
          <td class="paramname"><em>getch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int, int)&#160;</td>
          <td class="paramname"><em>ungetch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan and recognize input according to a format.</p>
<p>This is a minimal implementation and not all standard features are supported. The supported conversion specifications include:</p>
<ul>
<li><code>%s</code> to scan a whitespace-delimited string</li>
<li><code>%o</code> to scan an octal number (<code>%O</code> for long)</li>
<li><code>%x</code> to scan a hexideminal number (<code>%X</code> for long)</li>
<li><code>%c</code> to scan a sequence of characters</li>
<li><code>%</code>[ to scan a sequence of characters from the specified set</li>
<li><code>%%</code> to match a literal percent sign</li>
<li>All other conversion specifiers, including <code>%d</code> and <code>%u</code>, are interpreted as specifying a decimal number.</li>
<li>Whitespace to match any amount of whitespace in the input.</li>
<li>Maximum length modifier</li>
<li><code>'l'</code> type modifier to parse a long int rather than a normal int</li>
<li><code>'h'</code> type modifier to parse a short int rather than a normal int</li>
<li><code>'*'</code> character to suppress assignment</li>
</ul>
<p>If a feature is not mentioned above, assume it is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>format string for the scan </td></tr>
    <tr><td class="paramname">ap</td><td>variable-length list of locations to store the scanned data </td></tr>
    <tr><td class="paramname">getch</td><td>Function to get a character. It is expected to return the character as an <code>unsigned char</code> cast to an <code>int</code> on success, or <code>EOF</code> on end-of-file or read error. </td></tr>
    <tr><td class="paramname">ungetch</td><td>Function to unget a character. Unlike the standard ungetc(), this is not passed in an explicit character but instead uses the last read character, which will then be expected to be returned on the next getch() call. Only one character of putback needs to be supported. </td></tr>
    <tr><td class="paramname">arg1</td><td>First argument to <code>getch</code> and <code>ungetch</code>. </td></tr>
    <tr><td class="paramname">arg2</td><td>Second argument to <code>getch</code> and <code>ungetch</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items successfully matched and assigned, which may be less than the number of format specifiers in the case of a matching failure; alternatively, if EOF or a read error occurs before any matches, EOF is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb20b44c8437544e571a3cb9bb2cc37d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int abs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the absolute value of an integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The integer to get the absolute value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of <code>j</code>. As a special case, if <code>j</code> is <code>INT_MIN</code>, the return value will be undefined because <code>-INT_MIN</code> cannot be represented in an <code>int</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad228deceea1bac4d9f171f647c265059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int atoi </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the initial portion of an ASCII null-terminated string into an integer. Leading whitespace is skipped and an optional <code>+</code> or <code>-</code> character is allowed to indicate sign. Parsing otherwise stops once the first nondigit character is encountered. If no digits have been encountered at that point, 0 shall be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to the string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga185551efd32d058ef290ebe2d144219f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long atol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the initial portion of an ASCII null-terminated string into a long integer. Leading whitespace is skipped and an optional <code>+</code> or <code>-</code> character is allowed to indicate sign. Parsing otherwise stops once the first nondigit character is encountered. If no digits have been encountered at that point, 0 shall be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>Pointer to the string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting long integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59505af7f1c47ff01fdb944801642033"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bzero </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zeroes a block of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the start of the block of memory to zero. </td></tr>
    <tr><td class="paramname">n</td><td>Length of the block of memory, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga331dd7c56def5258f0385d1e5f9220c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fgetc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a character from a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Index of device from which to read the character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the character read as an <code>unsigned char</code> cast to an <code>int</code>. On read error, invalid device, or end-of file, returns <code>EOF</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga573c8ad59f73c997adb58ea83a5a879a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* fgets </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a newline-terminated string from a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The buffer in which to place the resulting data. </td></tr>
    <tr><td class="paramname">n</td><td>One less than the maximum number of characters to read. </td></tr>
    <tr><td class="paramname">dev</td><td>The index of the device from which to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns a pointer to the buffer <code>s</code>. On <code>EOF</code> before any characters were read, read error, or invalid device, returns <code>NULL</code>. On success, the resulting buffer will contain a null-terminated string that is the read data up until the first of the next newline, the end of the buffer, or the point at which <code>EOF</code> was reached on the device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4112ec293c0482854c66caaa708457c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fprintf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a formatted message to the specified device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Index of the device to write to. </td></tr>
    <tr><td class="paramname">format</td><td>The format string. Not all standard conversion specifications are supported by this implementation. See <a class="el" href="group__libxc.html#gaf48b30d4bbe6f24fac50996ad08dee81">_doprnt()</a> for a description of supported conversion specifications. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments matching those in the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the number of characters written. On write error, returns a negative value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32f19bdc96eb7c1eda177e01344f8c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fputc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes one character to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to write. </td></tr>
    <tr><td class="paramname">dev</td><td>Index of the device to which to write the character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the character written as an <code>unsigned char</code> cast to an <code>int</code>. On write error or invalid device, returns <code>EOF</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52df17ca21d792b6abb1559a77feaa13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fputs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a null-terminated string to a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The null terminated string to write. </td></tr>
    <tr><td class="paramname">dev</td><td>The device to write the string to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-negative number on success, or <code>EOF</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gafbedc913aa4651b3c3b4b3aecd9b4711"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to free a block of memory based on <a class="el" href="group__libxc.html#ga7ac38fce3243a7dcf448301ee9ffd392">malloc()</a> accounting information stored in preceding two words.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the memory block to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf9412bab60c15683f2cbf5397970bf38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fscanf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan input from a device according to the specified format string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Index of the device from which to scan input. </td></tr>
    <tr><td class="paramname">format</td><td>Format string. Not all standard format specifiers are supported by this implementation. See <a class="el" href="group__libxc.html#ga166404d618b580eb27442b03d55004fd">_doscan()</a> for a description of supported conversion specifications.</td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments that match those specified in the format string. Generally these need to be a <em>pointer</em> to the corresponding argument so that the value can be set; for example, a <code>%d</code> conversion specifier needs to be matched with an <code>int *</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items successfully matched and assigned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga912277f2dbf3594e958d116ff2b35625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long labs </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the absolute value of a long integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The long integer to get the absolute value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of <code>j</code>. As a special case, if <code>j</code> is <code>LONG_MIN</code>, the return value will be undefined because <code>-LONG_MIN</code> cannot be represented in a <code>long</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ac38fce3243a7dcf448301ee9ffd392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request heap storage, record accounting information, returning pointer to assigned memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>number of bytes requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to region on success, or <code>NULL</code> on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga16d6b0bd660cc3f9910924c6b6f4af8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* memchr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the first location in a region of memory at which a particular byte appears.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A pointer to the memory region to search. </td></tr>
    <tr><td class="paramname">c</td><td>The byte to locate. </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of bytes to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first occurrence of <code>c</code> in the memory region, or <code>NULL</code> if <code>c</code> was not found in the memory region. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e6df54ee04e18a3772335580e2ed872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two memory regions of a specified length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to the first memory location. </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to the second memory location. </td></tr>
    <tr><td class="paramname">n</td><td>Length, in bytes, to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative value, 0, or a positive value if the <code>s1</code> region of memory is less than, equal to, or greater than the <code>s2</code> region of memory, respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14938524dcbeb59d7117ba5e151ad1b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the specified number of bytes of memory to another location. The memory locations must not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the destination memory. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the source memory. </td></tr>
    <tr><td class="paramname">n</td><td>The amount of data (in bytes) to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dest</code> </dd></dl>

</div>
</div>
<a class="anchor" id="gace6ee45c30e71865e6eb635200379db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a region of memory with a byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the memory to place byte into </td></tr>
    <tr><td class="paramname">c</td><td>byte to place </td></tr>
    <tr><td class="paramname">n</td><td>length of region to fill, in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>s</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga98631211a4a8aee62f572375d5b637be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a formatted message to standard output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string. Not all standard format specifiers are supported by this implementation. See <a class="el" href="group__libxc.html#gaf48b30d4bbe6f24fac50996ad08dee81">_doprnt()</a> for a description of supported conversion specifications. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments matching those in the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the number of characters written. On write error, returns a negative value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga216aaec88b41d3e2f8502a5b3365ea81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qsort </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts an array of data using quicksort. The average-case running time is O(n log n) but the worst case running time is O(n^2).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to the array of data to sort. </td></tr>
    <tr><td class="paramname">nmemb</td><td>Number of elements in the array. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each element in the array, in bytes. </td></tr>
    <tr><td class="paramname">compar</td><td>Comparison callback function that is passed pointers to two elements in the array. It must return a negative value, 0, or a positive value if the first element is less than, equal to, or greater than the second element, respectively. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae23144bcbb8e3742b00eb687c36654d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a pseudorandom integer in the range [0, RAND_MAX]. Beware: this is not re-entrant.</p>
<dl class="section return"><dt>Returns</dt><dd>the random integer </dd></dl>

</div>
</div>
<a class="anchor" id="ga3082155ec11e7229f7a20439b31a169e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a formatted message to a null-terminated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The output string, which must be large enough to store the formatted result, including the null terminator. </td></tr>
    <tr><td class="paramname">format</td><td>The format string. Not all standard conversion specifications are supported by this implementation. See <a class="el" href="group__libxc.html#gaf48b30d4bbe6f24fac50996ad08dee81">_doprnt()</a> for a description of supported conversion specifications. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments matching those in the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters written, excluding the null terminator. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa76dd6cc9eff8b0475a781caf9782d73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srand </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the random seed that will be used in future calls to <a class="el" href="group__libxc.html#gae23144bcbb8e3742b00eb687c36654d1">rand()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the random seed to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec1e54556dca3bd701d44395d34818dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sscanf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan values from a string according to the specified format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String from which to read input. </td></tr>
    <tr><td class="paramname">format</td><td>Format string. Not all standard format specifiers are supported by this implementation. See <a class="el" href="group__libxc.html#ga166404d618b580eb27442b03d55004fd">_doscan()</a> for a description of supported conversion specifications. </td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments that match those specified in the format string. Generally these need to be a <em>pointer</em> to the corresponding argument so that the value can be set; for example, a <code>%d</code> conversion specifier needs to be matched with an <code>int *</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of items successfully matched. </dd></dl>

</div>
</div>
<a class="anchor" id="ga12871ed234858ef0e363d2b8aa572fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* strchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the first location in a null-terminated string at which a particular character appears.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to search. </td></tr>
    <tr><td class="paramname">c</td><td>The character to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer in the string, or <code>NULL</code> if the character was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga11bd144d7d44914099a3aeddf1c8567d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two null-terminated strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to the first string. </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to the second string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative value, 0, or a positive value if the <code>s1</code> string is less than, equal to, or greater than the <code>s2</code> string, respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a82515b5d377be04817715c5465b647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a a null-terminated string to the specified location. The source and destination strings may not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the memory to which to copy the string. It must have room for at least the number of characters in the <code>src</code> string, including the null terminator. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the string to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to <code>dest</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e0c58f8ba41f9267161ffca2ea92558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a null-terminated string into a fixed-size buffer. Unlike <a class="el" href="group__libxc.html#ga47d54f24198df56da51078a6c540b9ed">strncpy()</a>, this will perform truncation as expected, and the resulting destination string is guaranteed to be null-terminated (unless <code>destsize</code> was 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the buffer into which to copy the string. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the null-terminated string to copy. </td></tr>
    <tr><td class="paramname">destsize</td><td>Size of the <code>dest</code> buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the <code>src</code> string. This can be tested to detect whether truncation was performed. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa383452fe445bfae989358c9d7d96f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the length of a null-terminated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to calculate the length of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the string in bytes, not including the null terminator. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0aee928c2844a269966e4832fd2255c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* strncat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate at most the specified number of characters from a possibly null-terminated string to another null-terminated string, always null-terminating the result. The strings may not overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the null-terminated string to which to concatenate the additional string or characters. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the source string.</td></tr>
    <tr><td class="paramname">n</td><td>Maximum number of bytes of the <code>src</code> string to concatenate, excluding the null terminator that will be appended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>dest</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga07f4a84c11c106e95c32b6ab509346ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two null-terminated strings, examining at most the specified number of bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to the first string. </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to the second string. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum number of bytes to compare before returning 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative value, 0, or a positive value if the <code>s1</code> string is less than, equal to, or greater than the <code>s2</code> string, respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47d54f24198df56da51078a6c540b9ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* strncpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies at most <code>n</code> bytes of a string to a new location. The source string may or may not be null-terminated, but if it is and the null terminator is present in the first <code>n</code> bytes, then copying will stop early when it is reached. If less than <code>n</code> bytes were copied, then the remaining bytes in the destination will be set to null characters until <code>n</code> bytes total have been written.</p>
<p><b>Beware: if the source string does not contain a null terminator in its first <code>n</code> bytes, the destination will not be null-terminated. To correctly write a null-terminated string into a fixed-size buffer with truncation as expected, consider using <a class="el" href="group__libxc.html#ga3e0c58f8ba41f9267161ffca2ea92558">strlcpy()</a> instead.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Pointer to the memory to which to copy the string. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the string to copy. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to fill (see above description).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to <code>dest</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc92d2231e45d19988c7894aa2a07f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t strnlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of a null-terminated string, but not more than the specified length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to calculate the length of.</td></tr>
    <tr><td class="paramname">maxlen</td><td>Maximum length to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the string up to but not including the null terminator, or <code>maxlen</code> if the string is longer than <code>maxlen</code> bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c05a458deff028ef4d4e64059098db4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* strrchr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the last location in a null-terminated string at which a particular character appears.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to search. </td></tr>
    <tr><td class="paramname">c</td><td>The character to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer in the string, or <code>NULL</code> if the character was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a710d86541afc6b7dafddcdb4b1c94f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* strstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the first location in a null-terminated string at which a particular substring appears.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string to search. </td></tr>
    <tr><td class="paramname">needle</td><td>The string to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer in the string, or <code>NULL</code> if the string was not found. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
