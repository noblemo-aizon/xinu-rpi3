<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Embedded Xinu Operating System: USB Core Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Embedded Xinu Operating System
   </div>
   <div id="projectbrief">An ongoing research project and educational operating system.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB Core Driver<div class="ingroups"><a class="el" href="group__usb.html">USB</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>USB device model and API for USB device drivers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:usbcore_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbcore_8c.html">usbcore.c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:usbdebug_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbdebug_8c.html">usbdebug.c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga04500240d93eaedb734240929e5a06be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga04500240d93eaedb734240929e5a06be">usb_init_xfer_request</a> (struct usb_xfer_request *req)</td></tr>
<tr class="separator:ga04500240d93eaedb734240929e5a06be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7daf3baaa97a513d71f323d0f9391fb9"><td class="memItemLeft" align="right" valign="top">struct usb_xfer_request *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga7daf3baaa97a513d71f323d0f9391fb9">usb_alloc_xfer_request</a> (uint bufsize)</td></tr>
<tr class="separator:ga7daf3baaa97a513d71f323d0f9391fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef47c1a9b0707276d121214cdd461d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga4ef47c1a9b0707276d121214cdd461d0">usb_free_xfer_request</a> (struct usb_xfer_request *req)</td></tr>
<tr class="separator:ga4ef47c1a9b0707276d121214cdd461d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873be6d448b1c95c51cb5600a197cf64"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga873be6d448b1c95c51cb5600a197cf64">usb_submit_xfer_request</a> (struct usb_xfer_request *req)</td></tr>
<tr class="separator:ga873be6d448b1c95c51cb5600a197cf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf82a9972b273a0e842212e2d638272b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#gabf82a9972b273a0e842212e2d638272b">usb_complete_xfer</a> (struct usb_xfer_request *req)</td></tr>
<tr class="separator:gabf82a9972b273a0e842212e2d638272b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4d0b3195ae857828f75b9c3f084ff9"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg</a> (struct usb_device *dev, const struct usb_endpoint_descriptor *endpoint_desc, uint8_t bRequest, uint8_t bmRequestType, uint16_t wValue, uint16_t wIndex, void *data, uint16_t wLength)</td></tr>
<tr class="separator:ga0b4d0b3195ae857828f75b9c3f084ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421272b0f3799410bc7089f29b822c8c"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga421272b0f3799410bc7089f29b822c8c">usb_get_descriptor</a> (struct usb_device *dev, uint8_t bRequest, uint8_t bmRequestType, uint16_t wValue, uint16_t wIndex, void *buf, uint16_t buflen)</td></tr>
<tr class="separator:ga421272b0f3799410bc7089f29b822c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf176c490fcac1b9ec676669f1d235dae"><td class="memItemLeft" align="right" valign="top">struct usb_device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#gaf176c490fcac1b9ec676669f1d235dae">usb_alloc_device</a> (struct usb_device *parent)</td></tr>
<tr class="separator:gaf176c490fcac1b9ec676669f1d235dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1276a0bdafec25f3313ecd6839c51e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga1276a0bdafec25f3313ecd6839c51e25">usb_free_device</a> (struct usb_device *dev)</td></tr>
<tr class="separator:ga1276a0bdafec25f3313ecd6839c51e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42564b27159fcf3073738ad16e9aa287"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga42564b27159fcf3073738ad16e9aa287">usb_attach_device</a> (struct usb_device *dev)</td></tr>
<tr class="separator:ga42564b27159fcf3073738ad16e9aa287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b99d5980034f7f1f183218e609c801f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga6b99d5980034f7f1f183218e609c801f">usb_lock_bus</a> (void)</td></tr>
<tr class="separator:ga6b99d5980034f7f1f183218e609c801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf957391ad00401a906dbeb919183f56c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#gaf957391ad00401a906dbeb919183f56c">usb_unlock_bus</a> (void)</td></tr>
<tr class="separator:gaf957391ad00401a906dbeb919183f56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33403372a738979110884fd1b3f4c474"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga33403372a738979110884fd1b3f4c474">usb_register_device_driver</a> (const struct usb_device_driver *drv)</td></tr>
<tr class="separator:ga33403372a738979110884fd1b3f4c474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe97aa2be2cc2aba482c64309cd7f88d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#gafe97aa2be2cc2aba482c64309cd7f88d">usb_status_string</a> (usb_status_t status)</td></tr>
<tr class="separator:gafe97aa2be2cc2aba482c64309cd7f88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3609ee36c2101d9179594f7cfef176e9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga3609ee36c2101d9179594f7cfef176e9">usb_class_code_to_string</a> (enum usb_class_code class_code)</td></tr>
<tr class="separator:ga3609ee36c2101d9179594f7cfef176e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe8839660a728bd1bc378acd5e54ad6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga3fe8839660a728bd1bc378acd5e54ad6">usb_speed_to_string</a> (enum usb_speed speed)</td></tr>
<tr class="separator:ga3fe8839660a728bd1bc378acd5e54ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799108acda1af1559339b779bf11d201"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga799108acda1af1559339b779bf11d201">usb_transfer_type_to_string</a> (enum usb_transfer_type type)</td></tr>
<tr class="separator:ga799108acda1af1559339b779bf11d201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86b850733f589f1d2c9443934cdaf8f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#gac86b850733f589f1d2c9443934cdaf8f">usb_direction_to_string</a> (enum usb_direction dir)</td></tr>
<tr class="separator:gac86b850733f589f1d2c9443934cdaf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46b81024db6dce7812618f41e288c1df"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga46b81024db6dce7812618f41e288c1df">usb_get_string_descriptor</a> (struct usb_device *dev, uint8_t index, uint16_t lang_id, struct usb_string_descriptor *buf, uint16_t buflen)</td></tr>
<tr class="separator:ga46b81024db6dce7812618f41e288c1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ec2ced3150725518a49629137e68c7"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#ga10ec2ced3150725518a49629137e68c7">usb_get_ascii_string</a> (struct usb_device *dev, uint32_t iString, char *strbuf, uint32_t strbufsize)</td></tr>
<tr class="separator:ga10ec2ced3150725518a49629137e68c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30f9b5d46f045da04d6150e8d662763"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbcore.html#gae30f9b5d46f045da04d6150e8d662763">usb_device_description</a> (const struct usb_device *dev)</td></tr>
<tr class="separator:gae30f9b5d46f045da04d6150e8d662763"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>USB device model and API for USB device drivers. </p>
<p>This is the USB Core Driver. It implements the USB system software that does not depend on the specific host controller hardware and is not specific to any single USB device or platform.</p>
<p>Features and limitations:</p>
<ul>
<li>This driver is written to be compatible with USB 2.0. USB 3.0 devices are untested.</li>
<li>Not all USB transfer types and speeds are necessarily supported. This depends on the Host Controller Driver; see <a class="el" href="group__usbcore.html#ga873be6d448b1c95c51cb5600a197cf64">usb_submit_xfer_request()</a>.</li>
<li>This driver does not attempt to do any intelligent power management, bandwidth allocation, or transfer scheduling. Devices are always set to their first listed configuration regardless of power requirements. Transfer requests are simply passed to the Host Controller Driver in the order submitted; thus, the Host Controller Driver is responsible for doing any more intelligent scheduling if desired.</li>
<li>This driver is assumed to drive a single USB (bus). Multiple USBs are not supported.</li>
<li>This driver does not support multiple configurations per USB device. If a device happens to have multiple configurations, the first one will be assigned.</li>
<li>This driver is currently written to support binding drivers to USB devices rather than USB interfaces.</li>
<li>By design, it is possible to implement a host controller driver for different host controller hardware without changing any of this code, as long as the host controller driver provides the functions declared in usb_hcdi.h.</li>
<li>By design, this driver has a hard-coded dependency on the USB hub driver because USB is useless without hubs.</li>
</ul>
<p>To initialize this core USB driver, <a class="el" href="group__usb.html#ga44a089d3d6c6297f5880f14eeb1d6397">usbinit()</a> must be called by the system startup code. See that function for details.</p>
<p>The other functions exported by this core USB driver are mostly intended to be used by USB device drivers.</p>
<p>Debugging messages in this driver and in the rest of the USB code can be enabled by changing the definitions of the minimum, initial, and/or background log priorities in usb_util.h. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf176c490fcac1b9ec676669f1d235dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct usb_device* usb_alloc_device </td>
          <td>(</td>
          <td class="paramtype">struct usb_device *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a USB device structure from the pool of available device structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Pointer to the USB device structure for the parent hub, or <code>NULL</code> if the device being allocated is the root hub.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to an initialized USB device structure, or <code>NULL</code> if no more USB device structures are available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7daf3baaa97a513d71f323d0f9391fb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct usb_xfer_request* usb_alloc_xfer_request </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>bufsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically allocates a struct usb_xfer_request, including a data buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufsize</td><td>Length of the data buffer for sending and/or receiving.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the resulting struct usb_xfer_request, or NULL if out of memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ga42564b27159fcf3073738ad16e9aa287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t usb_attach_device </td>
          <td>(</td>
          <td class="paramtype">struct usb_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure and initialize, or "enumerate", a newly allocated USB device. The physical device is initially assumed to be non-addressed and non-configured and therefore accessible by sending control messages to the default address of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>New USB device to configure and initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>::USB_STATUS_SUCCESS if successful; another ::usb_status_t error code otherwise. Note that after a succesful return, the newly attached device may or may not have been bound to an actual device driver. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3609ee36c2101d9179594f7cfef176e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* usb_class_code_to_string </td>
          <td>(</td>
          <td class="paramtype">enum usb_class_code&#160;</td>
          <td class="paramname"><em>class_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates a USB class code into a string describing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_code</td><td>A USB class code constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant string describing the USB class, or "Unknown" if the class code was not recognized. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf82a9972b273a0e842212e2d638272b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_complete_xfer </td>
          <td>(</td>
          <td class="paramtype">struct usb_xfer_request *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal the device driver that a USB transfer has successfully completed or has encountered an error. Intended to be called by Host Controller Drivers only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>USB transfer to signal completion on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0b4d0b3195ae857828f75b9c3f084ff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t usb_control_msg </td>
          <td>(</td>
          <td class="paramtype">struct usb_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct usb_endpoint_descriptor *&#160;</td>
          <td class="paramname"><em>endpoint_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously performs a control transfer to or from a USB device. Control messages are one of the four fundamental transfer types of USB and are documented in various places in the USB 2.0 specification.</p>
<p>This is a synchronous interface, so the thread will be blocked until the control transfer has completed, timed out, or encountered another error. Currently the request timeout is chosen by the Host Controller Driver and cannot be passed as a parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the USB device to which to submit the control message. </td></tr>
    <tr><td class="paramname">endpoint_desc</td><td>Pointer to the endpoint descriptor for the endpoint to which to submit the control transfer, or NULL to specify the default control endpoint (which has no endpoint descriptor). </td></tr>
    <tr><td class="paramname">bRequest</td><td>Request to make. Standard device requests are documented in Section 9.4 of the USB 2.0 specification; in this code they are the enum ::usb_device_request values. Other values, such as class-specific requests, can also be used for this parameter. </td></tr>
    <tr><td class="paramname">bmRequestType</td><td>Type of the request to make. Standard types are documented in Section 9.3.1 of the USB 2.0 specification; in this code they are the enum ::usb_bmRequestType_fields values. </td></tr>
    <tr><td class="paramname">wValue</td><td>Request-specific data. </td></tr>
    <tr><td class="paramname">wIndex</td><td>Request-specific data. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to a buffer that, depending on the request, either contains the additional data to be sent as part of the message, or receives the additional data that will be received from the USB device. This parameter is ignored if <code>wLength</code> is 0. </td></tr>
    <tr><td class="paramname">wLength</td><td>Length of the <code>data</code> buffer. This is interpreted as the exact number of additional bytes of data that must be transferred. This can be 0 if no additional data needs to be transferred to satisfy the request; for example, a SetAddress request passes information in wValue but uses no additional data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the transfer. The possible return values include:</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">::USB_STATUS_SUCCESS</td><td>The transfer completed successfully with exactly the amount of data specified by <code>wLength</code>. </td></tr>
    <tr><td class="paramname">::USB_STATUS_OUT_OF_MEMORY</td><td>Failed to allocate memory or create a semaphore. </td></tr>
    <tr><td class="paramname">::USB_STATUS_INVALID_DATA</td><td>The transfer completed, but not with the exact amount of data specified. </td></tr>
    <tr><td class="paramname">::USB_STATUS_UNSUPPORTED_REQUEST</td><td>The transfer was to the root hub, but the request was not implemented. </td></tr>
    <tr><td class="paramname">::USB_STATUS_HARDWARE_ERROR</td><td>A hardware error occurred. </td></tr>
    <tr><td class="paramname">::USB_STATUS_DEVICE_DETACHED</td><td>The USB device was detached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae30f9b5d46f045da04d6150e8d662763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* usb_device_description </td>
          <td>(</td>
          <td class="paramtype">const struct usb_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a fairly detailed, human-readable description of a USB device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>USB device to get a description of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string describing the device. The returned string is statically allocated and will be changed on the next call to this function. </dd></dl>

</div>
</div>
<a class="anchor" id="gac86b850733f589f1d2c9443934cdaf8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* usb_direction_to_string </td>
          <td>(</td>
          <td class="paramtype">enum usb_direction&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates a USB direction constant into a string describing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>A USB direction constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"OUT", "IN", or "Unknown". </dd></dl>

</div>
</div>
<a class="anchor" id="ga1276a0bdafec25f3313ecd6839c51e25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_free_device </td>
          <td>(</td>
          <td class="paramtype">struct usb_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detaches and frees a USB device. This unbinds the device driver, if one is bound, and returns the USB device structure to the pool of available device structures. Only the hub driver should need to call this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the USB device structure to detach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ef47c1a9b0707276d121214cdd461d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_free_xfer_request </td>
          <td>(</td>
          <td class="paramtype">struct usb_xfer_request *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a struct usb_xfer_request allocated by <a class="el" href="group__usbcore.html#ga7daf3baaa97a513d71f323d0f9391fb9">usb_alloc_xfer_request()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>A pointer to the struct usb_xfer_request to free. It must not be currently pending. NULL can be passed as a no-op. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga10ec2ced3150725518a49629137e68c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t usb_get_ascii_string </td>
          <td>(</td>
          <td class="paramtype">struct usb_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>strbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>strbufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the English version (if any) of a USB string descriptor and "translates" it from UTF-16LE to ASCII. The resulting string is null-terminated. UTF-16LE codepoints outside the ASCII range are simply replaced with question marks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the USB device structure for the device from which to read the string descriptor. </td></tr>
    <tr><td class="paramname">iString</td><td>Index of the string descriptor to read. </td></tr>
    <tr><td class="paramname">strbuf</td><td>Buffer in which to place the ASCII string. </td></tr>
    <tr><td class="paramname">strbufsize</td><td>Length of the <code>strbuf</code> buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Any value that can be returned by <a class="el" href="group__usbcore.html#ga46b81024db6dce7812618f41e288c1df">usb_get_string_descriptor()</a>, plus ::USB_STATUS_INVALID_DATA if the list of available language IDs is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="ga421272b0f3799410bc7089f29b822c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t usb_get_descriptor </td>
          <td>(</td>
          <td class="paramtype">struct usb_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a descriptor from a USB device. This is a wrapper around <a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg()</a> that automatically handles reading the descriptor header and requesting the appropriate length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>USB device from which to read the descriptor. </td></tr>
    <tr><td class="paramname">bRequest</td><td>See <a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg()</a>. </td></tr>
    <tr><td class="paramname">bmRequestType</td><td>See <a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg()</a>. </td></tr>
    <tr><td class="paramname">wValue</td><td>See <a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg()</a>. </td></tr>
    <tr><td class="paramname">wIndex</td><td>See <a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>See <a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg()</a>. </td></tr>
    <tr><td class="paramname">buflen</td><td>See <a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same possible return values as <a class="el" href="group__usbcore.html#ga0b4d0b3195ae857828f75b9c3f084ff9">usb_control_msg()</a>, or ::USB_STATUS_INVALID_DATA if the bLength field in the descriptor header is less than the size of the descriptor header itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46b81024db6dce7812618f41e288c1df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t usb_get_string_descriptor </td>
          <td>(</td>
          <td class="paramtype">struct usb_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>lang_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct usb_string_descriptor *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a USB string descriptor from a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the USB device structure for the device from which to read the string descriptor. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the string descriptor to read. For example, the iProduct member of the device descriptor specifies the index of the string descriptor that contains the product name. </td></tr>
    <tr><td class="paramname">lang_id</td><td>Language ID of the language to request. Note: the available language IDs can be retrieved by requesting the string descriptor of index 0 with any language ID. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer in which to place the string descriptor. </td></tr>
    <tr><td class="paramname">buflen</td><td>Maximum length in bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group__usbcore.html#ga421272b0f3799410bc7089f29b822c8c">usb_get_descriptor()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga04500240d93eaedb734240929e5a06be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_init_xfer_request </td>
          <td>(</td>
          <td class="paramtype">struct usb_xfer_request *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs one-time initialization on a USB transfer request allocated by the device driver in some way other than by <a class="el" href="group__usbcore.html#ga7daf3baaa97a513d71f323d0f9391fb9">usb_alloc_xfer_request()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Pointer to the USB transfer request to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b99d5980034f7f1f183218e609c801f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_lock_bus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prevent devices from being attached or detached to/from the USB. This does not prevent USB transfers from being issued on the bus. </p>

</div>
</div>
<a class="anchor" id="ga33403372a738979110884fd1b3f4c474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t usb_register_device_driver </td>
          <td>(</td>
          <td class="paramtype">const struct usb_device_driver *&#160;</td>
          <td class="paramname"><em>drv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a USB device driver with the USB core. At any time after this is called, the USB core may execute the bind_device callback to try to bind the device driver to a USB device.</p>
<p>This currently can safely be called before <a class="el" href="group__usb.html#ga44a089d3d6c6297f5880f14eeb1d6397">usbinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv</td><td>Pointer to the USB device driver structure to register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>::USB_STATUS_SUCCESS if the driver was successfully registered or was already registered; otherwise another ::usb_status_t error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3fe8839660a728bd1bc378acd5e54ad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* usb_speed_to_string </td>
          <td>(</td>
          <td class="paramtype">enum usb_speed&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates a USB speed constant into a string describing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>A USB speed constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"high", "full", "low", or "unknown". </dd></dl>

</div>
</div>
<a class="anchor" id="gafe97aa2be2cc2aba482c64309cd7f88d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* usb_status_string </td>
          <td>(</td>
          <td class="paramtype">usb_status_t&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates a ::usb_status_t into a string describing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>A ::usb_status_t error code returned by one of the functions in Xinu's USB subsystem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant string describing the error, or "unknown error" if the error code is not recognized. </dd></dl>

</div>
</div>
<a class="anchor" id="ga873be6d448b1c95c51cb5600a197cf64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t usb_submit_xfer_request </td>
          <td>(</td>
          <td class="paramtype">struct usb_xfer_request *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Submit a USB transfer request to be completed.</p>
<p>This is intended to be an asynchronous interface where the transfer request is queued for later processing by the Host Controller. This function should immediately return and the transfer request should be asynchronously completed at some later time, making use of interrupts between the CPU and host controller to accomplish this efficiently. However, exactly how the transfer request is completed is ultimately up to the Host Controller Driver. Synchronous completion is possible, although not recommended.</p>
<p>When the transfer has been completed or has failed, the completion_cb_func function of the <code>req</code> will be called. This callback function should process the completed or failed request and either free its memory or re-submit it to start another transfer.</p>
<p>Not all USB transfer types and speeds are necessarily supported. This depends on the Host Controller Driver, which is expected to make sure each request is supported when passed it and return ::USB_STATUS_INVALID_PARAMETER if not. Currently, the Host Controller Driver for the Synopsys DesignWare High-Speed USB 2.0 On-The-Go Controller (the one on the Raspberry Pi) is intended to support control, bulk, and interrupt transfers at low, full, and high speeds; however, not all combinations of transfers and speeds have actually been tested yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Pointer to the USB transfer request to submit. Its members documented as input must have been filled in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">::USB_STATUS_SUCCESS</td><td>The request was submitted successfully. </td></tr>
    <tr><td class="paramname">::USB_STATUS_INVALID_PARAMETER</td><td><code>req</code> was not filled in correctly. </td></tr>
    <tr><td class="paramname">::USB_STATUS_DEVICE_DETACHED</td><td>The device has been detached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga799108acda1af1559339b779bf11d201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* usb_transfer_type_to_string </td>
          <td>(</td>
          <td class="paramtype">enum usb_transfer_type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates a USB transfer type constant into a string describing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>A USB transfer type constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"Control", "Isochronous", "Bulk", "Interrupt", or "Unknown". </dd></dl>

</div>
</div>
<a class="anchor" id="gaf957391ad00401a906dbeb919183f56c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usb_unlock_bus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Undo <a class="el" href="group__usbcore.html#ga6b99d5980034f7f1f183218e609c801f">usb_lock_bus()</a>, allowing devices to be attached or detached to/from the USB. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
