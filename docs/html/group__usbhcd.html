<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Embedded Xinu Operating System: USB Host Controller Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Embedded Xinu Operating System
   </div>
   <div id="projectbrief">An ongoing research project and educational operating system.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB Host Controller Driver<div class="ingroups"><a class="el" href="group__usb.html">USB</a> &#124; <a class="el" href="group__system.html">System Calls</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Platform-dependent code to actually send and receive data over the USB.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:usb__dwc__hcd_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usb__dwc__hcd_8c.html">usb_dwc_hcd.c</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7b5f13b20e154376312b7514f9dbcb81"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbhcd.html#ga7b5f13b20e154376312b7514f9dbcb81">dwc_intr_status</a> { <br/>
&#160;&#160;<b>XFER_COMPLETE</b> = 0, 
<b>XFER_FAILED</b> = 1, 
<b>XFER_NEEDS_DEFERRAL</b> = 2, 
<b>XFER_NEEDS_RESTART</b> = 3, 
<br/>
&#160;&#160;<b>XFER_NEEDS_TRANS_RESTART</b> = 4
<br/>
 }</td></tr>
<tr class="separator:ga7b5f13b20e154376312b7514f9dbcb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaab6ab94dcc19ea7a80aed9af1c44ab7d"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbhcd.html#gaab6ab94dcc19ea7a80aed9af1c44ab7d">hcd_start</a> (void)</td></tr>
<tr class="separator:gaab6ab94dcc19ea7a80aed9af1c44ab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058fc081836262ad2376911fcf7cf14b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbhcd.html#ga058fc081836262ad2376911fcf7cf14b">hcd_stop</a> (void)</td></tr>
<tr class="separator:ga058fc081836262ad2376911fcf7cf14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72b7448515ed0c92480cb6737009e626"><td class="memItemLeft" align="right" valign="top">usb_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__usbhcd.html#ga72b7448515ed0c92480cb6737009e626">hcd_submit_xfer_request</a> (struct usb_xfer_request *req)</td></tr>
<tr class="separator:ga72b7448515ed0c92480cb6737009e626"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Platform-dependent code to actually send and receive data over the USB. </p>
<p>USB Host Controller Driver specifies protocols for USB transfers.</p>
<p>This is a USB Host Controller Driver (HCD) that interfaces with the Synopsys DesignWare Hi-Speed USB 2.0 On-The-Go Controller, henceforth abbreviated as "DWC". This is the USB Host Controller used on the BCM2835 SoC used on the Raspberry Pi.</p>
<p>Please note that there is no publicly available official documentation for this particular piece of hardware, and it uses its own custom host controller interface rather than a standard one such as EHCI. Therefore, this driver was written on a best-effort basis using several sources to gleam the necessary hardware details, including the extremely complicated and difficult to understand vendor-provided Linux driver.</p>
<p>This file implements the Host Controller Driver Interface defined in usb_hcdi.h. Most importantly, it implements a function to power on and start the host controller (<a class="el" href="group__usbhcd.html#gaab6ab94dcc19ea7a80aed9af1c44ab7d">hcd_start()</a>) and a function to send and receive messages over the USB (<a class="el" href="group__usbhcd.html#ga72b7448515ed0c92480cb6737009e626">hcd_submit_xfer_request()</a>).</p>
<p>The DWC is controlled by reading and writing to/from memory-mapped registers. The most important registers are the host channel registers. On this particular hardware, a "host channel", or simply "channel", is a set of registers to which software can read and write to cause transactions to take place on the USB. A fixed number of host channels exist; on the Raspberry Pi there are 8. From the software's perspective, transactions using different host channels can be executed at the same time.</p>
<p>Some of the host channel registers, as well as other registers, deal with interrupts. This driver makes use heavy of these and performs all USB transfers in an interrupt-driven manner. However, due to design flaws in this hardware and in USB 2.0 itself, "interrupt" and "isochronous" transfers still need to make use of software polling when checking for new data, even though each individual transfer is itself interrupt-driven. This means that, for example, if your USB mouse specifies a polling rate of 100 times per second, then it will, unfortunately, be polled 100 times per second in software. For more detail about how interrupts can be controlled on this particular hardware, see the comment above dwc_setup_interrupts().</p>
<p>Another important concept is the idea of "packets", "transactions", and "transfers". A USB transfer, such as a single control message or bulk request, may need to be split into multiple packets if it exceeds the endpoint's maximum packet size. Unfortunately, this has to be dealt with explicitly in this code, as this hardware doesn't do it for us. But at least, from the viewpoint of this software, a "transaction" is essentially the same as a "packet".</p>
<p>The "On-The-Go" in the name of this hardware means that it supports the USB On-The-Go protocol, which allows it to act either as a host or a device. However, we only are concerned with it acting as a host, which simplifies our driver.</p>
<p>To simplify the USB core software, a useful design technique (as recommended by the USB 2.0 standard and used in other implementations such as Linux's) is to have the HCD present the root hub as a standard USB hub, even if the root hub is integrated with the host controller and does not appear as a standard hub at the hardware level. This is the case with the DWC, and we implement this design. Therefore, some code in this file deals with faking requests sent to the root hub. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga7b5f13b20e154376312b7514f9dbcb81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__usbhcd.html#ga7b5f13b20e154376312b7514f9dbcb81">dwc_intr_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal transfer status codes used to simplify interrupt handling. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaab6ab94dcc19ea7a80aed9af1c44ab7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t hcd_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of <a class="el" href="group__usbhcd.html#gaab6ab94dcc19ea7a80aed9af1c44ab7d">hcd_start()</a> for the DesignWare Hi-Speed USB 2.0 On-The-Go Controller. See usb_hcdi.h for the documentation of this interface of the Host Controller Driver. </p>
<dl class="section return"><dt>Returns</dt><dd>::USB_STATUS_SUCCESS on successful intitialization of the HCD; otherwise, return ::USB_STATUS_HARDWARE_ERROR or ::USB_STATUS_OUT_OF_MEMORY </dd></dl>

</div>
</div>
<a class="anchor" id="ga058fc081836262ad2376911fcf7cf14b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hcd_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of <a class="el" href="group__usbhcd.html#ga058fc081836262ad2376911fcf7cf14b">hcd_stop()</a> for the DesignWare Hi-Speed USB 2.0 On-The-Go Controller. See usb_hcdi.h for the documentation of this interface of the Host Controller Driver. </p>

</div>
</div>
<a class="anchor" id="ga72b7448515ed0c92480cb6737009e626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_status_t hcd_submit_xfer_request </td>
          <td>(</td>
          <td class="paramtype">struct usb_xfer_request *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation of <a class="el" href="group__usbhcd.html#ga72b7448515ed0c92480cb6737009e626">hcd_submit_xfer_request()</a> for the DesignWare Hi-Speed USB 2.0 On-The-Go Controller. See usb_hcdi.h for the documentation of this interface of the Host Controller Driver. </p>
<dl class="section return"><dt>Returns</dt><dd>::USB_STATUS_SUCCESS after successful sending of mailbox message, ::SYSERR if failure within <a class="el" href="group__mailbox.html#gab65abe313a4976eab021cd99258ff7e7">mailboxSend()</a></dd></dl>
<p>This Host Controller Driver implements this interface asynchronously, as intended. Furthermore, it uses a simplistic scheduling algorithm where it places transfer requests into a single queue and executes them in the order they were submitted. Transfers that need to be retried, including periodic transfers that receive a NAK reply and split transactions that receive a NYET reply when doing the Complete Split transaction, are scheduled to be retried at an appropriate time by separate code that shortcuts the main queue when the timer expires.</p>
<p>Jump to dwc_schedule_xfer_requests() to see what happens next. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
